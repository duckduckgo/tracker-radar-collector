const fs = require('fs');
const path = require('path');
const { OpenAI } = require('openai');
const { Command } = require('commander');
const { applyDetectionHeuristics } = require('./detection.js');
const { generateRulesForSite } = require('./generation.js');
const { verifyButtonTexts } = require('./verification.js');


/**
 * @param {string} ruleName
 * @param {string[]} testUrls
 * @param {string[]} regions
 * @returns {string}
 */
function generateTestFile(ruleName, testUrls, regions) {
    return `import generateCMPTests from "../../playwright/runner";
generateCMPTests('${ruleName}', ${JSON.stringify(testUrls)}, {testOptIn: false, testSelfTest: false, onlyRegions: ${JSON.stringify(regions)}});
`;
}

/**
 * Find existing rules that match a given URL/domain.
 * @param {string} url - The URL to match against.
 * @param {ProcessedCookiePopup[]} cookiePopups - Array of processed cookie popups.
 * @param {AutoConsentCMPRule[]} existingRules - Array of existing rules.
 * @returns {AutoConsentCMPRule[]} Array of matching existing rules.
 */
function findMatchingExistingRules(url, cookiePopups, existingRules) {
    return existingRules.filter(rule => {
        if (rule.runContext && rule.runContext.urlPattern) {
            try {
                const pattern = new RegExp(rule.runContext.urlPattern);
                return pattern.test(url) || rule.vendorUrl === url || cookiePopups.some(popup => pattern.test(popup.origin));
            } catch {
                // Invalid regex, skip
                return false;
            }
        }
        return false;
    });
}

/**
 * Determine if a site should be processed for cookie popup rules based on existing CMP detection.
 * @param {import('../../collectors/CookiePopupsCollector').AutoconsentResult[]} cmps - The detected CMPs.
 * @returns {boolean} True if the site should be processed (no known CMPs found).
 */
function hasKnownCmp(cmps) {
    return (
        Array.isArray(cmps) &&
        cmps.length > 0 &&
        cmps.some(cmp => cmp &&
            cmp.name &&
            cmp.name.trim() !== '' &&
            cmp.succeeded &&
            !cmp.name.trim().startsWith('auto_')) // we may override existing autogenerated rules
    );
}

/**
 * Read all existing rules from the rules directory. Note that this will ALSO read rules that were generated by this script for other regions.
 * @param {string} rulesDir
 * @returns {Promise<AutoConsentCMPRule[]>}
 */
async function readExistingRules(rulesDir) {
    const files = await fs.promises.readdir(rulesDir);
    /** @type {AutoConsentCMPRule[]} */
    const result = [];
    await Promise.all(files.map(async file => {
        try {
            const filePath = path.join(rulesDir, file);
            const content = await fs.promises.readFile(filePath, 'utf8');
            const rule = JSON.parse(content);
            result.push(rule);
        } catch (err) {
            console.warn(`Failed to parse rule file ${file}:`, err);
        }
    }));
    return result;
}

/**
 * @param {{
 *  rule: AutoConsentCMPRule,
 *  url: string,
 *  rulesDir: string,
 *  testDir: string,
 *  autoconsentDir: string,
 *  region: string,
 * }} params
 * @returns {Promise<AutoconsentManifestFileData>}
 */
async function writeRuleFiles({rule, url, rulesDir, testDir, autoconsentDir, region}) {
    const ruleFilePath = path.join(rulesDir, `${rule.name}.json`);
    const relativeRuleFilePath = path.relative(autoconsentDir, ruleFilePath);
    await fs.promises.writeFile(ruleFilePath, JSON.stringify(rule, null, 4));
    const testFilePath = path.join(testDir, `${rule.name}.spec.ts`);
    const relativeTestFilePath = path.relative(autoconsentDir, testFilePath);
    await fs.promises.writeFile(testFilePath, generateTestFile(rule.name, [url], [region]));
    return {
        ruleName: rule.name,
        rulePath: relativeRuleFilePath,
        testPath: relativeTestFilePath,
    };
}

/**
 * Process cookie popups for a single site and generate/update rules.
 * @param {GlobalParams} globalParams
 * @param {{
 *  finalUrl: string, // URL of the site
 *  cookiePopupsData: import('../../collectors/CookiePopupsCollector').PopupData[], // raw cookie popup data
 *  existingRules: AutoConsentCMPRule[], // existing Autoconsent rules
 * }} params
 * @returns {Promise<{
 * processedCookiePopups: ProcessedCookiePopup[],
 * newRuleFiles: AutoconsentManifestFileData[],
 * updatedRuleFiles: AutoconsentManifestFileData[],
 * keptCount: number,
 * reviewNotes: ReviewNote[],
 * updatedExistingRules: AutoConsentCMPRule[],
 * }>}
 */
async function processCookiePopupsForSite(globalParams, {finalUrl, cookiePopupsData, existingRules}) {
    const { openai, rulesDir, testDir, autoconsentDir, region } = globalParams;
    // filter out popups that are not confirmed by LLM
    /** @type {ProcessedCookiePopup[]} */
    const processedCookiePopups = (
        await Promise.all(cookiePopupsData.map(popup => applyDetectionHeuristics(popup, openai)))
    ).filter(p => p && p.llmMatch);

    /** @type {AutoconsentManifestFileData[]} */
    const newRuleFiles = [];
    /** @type {AutoconsentManifestFileData[]} */
    const updatedRuleFiles = [];

    const updatedExistingRules = structuredClone(existingRules);

    if (processedCookiePopups.length === 0) {
        return { processedCookiePopups, newRuleFiles, updatedRuleFiles, keptCount: 0, reviewNotes: [], updatedExistingRules };
    }

    const matchingRules = findMatchingExistingRules(finalUrl, processedCookiePopups, existingRules);
    console.log(`Detected ${processedCookiePopups.length} unhandled cookie popup(s) on ${finalUrl} (matched ${matchingRules.length} existing rules)`);
    const { newRules, rulesToOverride, reviewNotes, keptCount } = generateRulesForSite(globalParams, finalUrl, processedCookiePopups, matchingRules);

    updatedExistingRules.push(...newRules);
    rulesToOverride.forEach(rule => {
        const index = updatedExistingRules.findIndex(r => r.name === rule.name);
        if (index !== -1) {
            updatedExistingRules[index] = rule;
        }
    });

    // Log review notes
    reviewNotes.forEach(note => {
        console.log(`${finalUrl}: ${note.note} ${JSON.stringify(note)}`);
    });

    await Promise.all(rulesToOverride.map(async rule => {
        console.log(`${finalUrl}: overriding rule ${rule.name}`);
        updatedRuleFiles.push(await writeRuleFiles({
            rule,
            url: finalUrl,
            rulesDir,
            testDir,
            autoconsentDir,
            region,
        }));
    }));

    await Promise.all(newRules.map(async ruleToWrite => {
        console.log(`${finalUrl}: new rule ${ruleToWrite.name}`);
        newRuleFiles.push(await writeRuleFiles({
            rule: ruleToWrite,
            url: finalUrl,
            rulesDir,
            testDir,
            autoconsentDir,
            region,
        }));
    }));

    return {
        processedCookiePopups,
        newRuleFiles,
        updatedRuleFiles,
        keptCount,
        reviewNotes,
        updatedExistingRules,
    };
}

/**
 * Process all crawl data files in the crawl directory.
 * @param {GlobalParams} globalParams
 * @param {AutoConsentCMPRule[]} existingRules
 * @returns {Promise<void>}
 */
async function processFiles(globalParams, existingRules) {
    const { crawlDir, region, rejectButtonTextsFile, otherButtonTextsFile, autoconsentManifestFile } = globalParams;
    let totalFiles = 0;
    let totalUnhandled = 0;
    let totalSitesWithNewRules = 0;
    let totalSitesWithPopups = 0;
    let totalSitesWithKnownCmps = 0;
    let totalRules = 0;
    let totalKeptRules = 0;
    let totalOverriddenRules = 0;
    let totalSitesWithKeptRules = 0;
    let totalSitesWithOverriddenRules = 0;

    let existingRulesAfter = structuredClone(existingRules);

    /** @type {Map<string, AutoconsentSiteManifest>} */
    const autoconsentManifest = new Map();
    const rejectButtonTexts = new Set();
    const otherButtonTexts = new Set();

    let dir;
    try {
        dir = await fs.promises.opendir(crawlDir);
    } catch (err) {
        console.error('Error reading directory:', err.message);
        return;
    }

    for await (const dirent of dir) {
        if (!dirent.isFile() || path.extname(dirent.name).toLowerCase() !== '.json') {
            continue;
        }
        totalFiles++;
        const fileName = dirent.name;
        const filePath = path.join(crawlDir, fileName);
        const fileContent = await fs.promises.readFile(filePath, 'utf8');
        /** @type {CrawlData} */
        let jsonData;
        try {
            jsonData = JSON.parse(fileContent);
            if (!jsonData || !jsonData.data) {
                console.warn(`Skipping ${fileName}: no data field`);
                continue;
            }
        } catch (err) {
            console.error(`Error processing file ${fileName}:`, err.message);
            continue;
        }

        if (jsonData.data.cookiepopups?.potentialPopups && jsonData.data.cookiepopups.potentialPopups.length > 0) {
            totalSitesWithPopups++;
        }

        if (hasKnownCmp(jsonData.data.cookiepopups.cmps)) {
            totalSitesWithKnownCmps++;
        } else {
            const { processedCookiePopups, newRuleFiles, updatedRuleFiles, keptCount, reviewNotes, updatedExistingRules } = await processCookiePopupsForSite(globalParams, {
                finalUrl: jsonData.finalUrl,
                cookiePopupsData: jsonData.data.cookiepopups.potentialPopups || [],
                existingRules: existingRulesAfter,
            });
            existingRulesAfter = updatedExistingRules;
            if (processedCookiePopups.length > 0) {
                totalUnhandled++;
            }
            // Collect button texts for analysis
            processedCookiePopups.flatMap(popup => popup.rejectButtons.map(button => button.text)).forEach(b => rejectButtonTexts.add(b));
            processedCookiePopups.flatMap(popup => popup.otherButtons.map(button => button.text)).forEach(b => otherButtonTexts.add(b));

            if (newRuleFiles.length > 0 || updatedRuleFiles.length > 0 || reviewNotes.length > 0) {
                autoconsentManifest.set(fileName, {
                    siteUrl: jsonData.finalUrl,
                    newlyCreatedRules: newRuleFiles,
                    updatedRules: updatedRuleFiles,
                    reviewNotes
                });
            }

            if (newRuleFiles.length > 0 || keptCount > 0 || updatedRuleFiles.length > 0) {
                if (newRuleFiles.length > 0) {
                    totalRules += newRuleFiles.length;
                    totalSitesWithNewRules++;
                }
                if (keptCount > 0) {
                    totalKeptRules += keptCount;
                    totalSitesWithKeptRules++;
                }
                if (updatedRuleFiles.length > 0) {
                    totalOverriddenRules += updatedRuleFiles.length;
                    totalSitesWithOverriddenRules++;
                }
            }
        }
    }
    await fs.promises.writeFile(rejectButtonTextsFile, Array.from(rejectButtonTexts).join('\n'));
    await fs.promises.writeFile(otherButtonTextsFile, Array.from(otherButtonTexts).join('\n'));

    await fs.promises.writeFile(autoconsentManifestFile, JSON.stringify(Object.fromEntries(autoconsentManifest), null, 4));

    console.log(`Summary for ${region}:`);
    console.log(`Total crawled sites: ${totalFiles}`);
    console.log(`Sites with popup-like elements: ${totalSitesWithPopups}`);
    console.log(`Sites with detected cookie popups: ${totalUnhandled + totalSitesWithKnownCmps}`);
    console.log(`  handled by Autoconsent: ${totalSitesWithKnownCmps}`);
    console.log(`  not handled by Autoconsent: ${totalUnhandled}`);
    console.log(`Generated ${totalRules} new rules for ${totalSitesWithNewRules} sites`);
    console.log(`Kept ${totalKeptRules} rules for ${totalSitesWithKeptRules} sites`);
    console.log(`Updated ${totalOverriddenRules} rules for ${totalSitesWithOverriddenRules} sites`);
    console.log(`Reject button texts (${rejectButtonTexts.size}) saved in ${rejectButtonTextsFile}`);
    console.log(`Other button texts (${otherButtonTexts.size}) saved in ${otherButtonTextsFile}`);
    console.log(`Actions manifest for ${autoconsentManifest.size} sites saved in ${autoconsentManifestFile}`);
}

async function main() {
    const program = new Command();
    program
        .description(`Generate autoconsent rules from a crawl directory
    Example:
        node post-processing/generate-autoconsent-rules/main.js --crawl-dir /mnt/efs/shared/crawler-data/2025-05-12/GB/3p-crawl/ --region GB --autoconsent-dir ../autoconsent
    `)
        .option('--crawl-dir <path>', 'Crawl directory')
        .option('--region <region>', 'Crawl region code')
        .option('--autoconsent-dir <path>', 'Autoconsent directory')
        .parse(process.argv);

    const options = program.opts();
    const crawlDir = options.crawlDir;
    const region = options.region;
    const autoconsentDir = options.autoconsentDir;

    if (!crawlDir || !region || !autoconsentDir) {
        program.outputHelp();
        process.exit(1);
    }

    // check that directories exist
    if (!fs.existsSync(autoconsentDir) || !fs.existsSync(crawlDir)) {
        console.error('Autoconsent directory or crawl directory not found:', autoconsentDir, crawlDir);
        process.exit(1);
    }

    const rulesDir = path.join(autoconsentDir, 'rules', 'generated');
    const testDir = path.join(autoconsentDir, 'tests', 'generated');
    const rejectButtonTextsFile = path.join(crawlDir, 'reject-button-texts.txt');
    const otherButtonTextsFile = path.join(crawlDir, 'other-button-texts.txt');
    const autoconsentManifestFile = path.join(crawlDir, '..', 'autoconsent-manifest.json');

    const openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY,
    });
    if (!fs.existsSync(testDir)) {
        await fs.promises.mkdir(testDir, { recursive: true });
    }
    if (!fs.existsSync(rulesDir)) {
        await fs.promises.mkdir(rulesDir, { recursive: true });
    }

    const existingRules = await readExistingRules(rulesDir);
    console.log(`Found ${existingRules.length} existing generated rules`);

    /** @type {GlobalParams} */
    const globalParams = {
        openai,
        crawlDir,
        rulesDir,
        testDir,
        autoconsentDir,
        region,
        rejectButtonTextsFile,
        otherButtonTextsFile,
        autoconsentManifestFile,
    };

    await processFiles(globalParams, existingRules);
    await verifyButtonTexts(globalParams);
}

main();

/**
 * @typedef {{
 *  data: {
 *      cookiepopups: import('../../collectors/CookiePopupsCollector').CookiePopupsCollectorResult;
 *  };
 *  finalUrl: string;
 * }} CrawlData
 */

/**
 * @typedef {import('../../collectors/CookiePopupsCollector').ButtonData} ButtonData
 */

/**
 * @typedef {import('../../collectors/CookiePopupsCollector').PopupData} PopupData
 */

/**
 * @typedef {import('../../node_modules/@duckduckgo/autoconsent/lib/rules').AutoConsentCMPRule} AutoConsentCMPRule
 */

/**
 * @typedef {PopupData & {
 *  llmMatch: boolean;
 *  regexMatch: boolean;
 *  rejectButtons: ButtonData[];
 *  otherButtons: ButtonData[];
 * }} ProcessedCookiePopup
 */

/**
 * @typedef {{
 *  note: string;
 *  url?: string;
 *  region?: string;
 *  ruleName?: string;
 *  ruleNames?: string[];
 *  existingRules?: string[];
 * }} ReviewNote
 */

/**
 * @typedef {{
 *  ruleName: string;
 *  rulePath: string;
 *  testPath: string;
 * }} AutoconsentManifestFileData
 */

/**
 * @typedef {{
 *  siteUrl: string;
 *  newlyCreatedRules: AutoconsentManifestFileData[];
 *  updatedRules: AutoconsentManifestFileData[];
 *  reviewNotes: ReviewNote[];
 * }} AutoconsentSiteManifest
 */

/**
 * @typedef {{
 *  openai: OpenAI,
 *  crawlDir: string,
 *  rulesDir: string,
 *  testDir: string,
 *  autoconsentDir: string,
 *  region: string,
 *  rejectButtonTextsFile: string,
 *  otherButtonTextsFile: string,
 *  autoconsentManifestFile: string,
 * }} GlobalParams
 */