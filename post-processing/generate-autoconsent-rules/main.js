const fs = require('fs');
const path = require('path');
const { Command } = require('commander');
const { generateRulesForSite } = require('./generation.js');

/**
 * @param {string} ruleName
 * @param {string[]} testUrls
 * @param {string[]} regions
 * @returns {string}
 */
function generateTestFile(ruleName, testUrls, regions) {
    return `import generateCMPTests from "../../playwright/runner";
generateCMPTests('${ruleName}', ${JSON.stringify(testUrls)}, {testOptIn: false, testSelfTest: true, onlyRegions: ${JSON.stringify(regions)}});
`;
}

/**
 * Find existing rules that match a given URL/domain.
 * @param {string} url - The URL to match against.
 * @param {import('./types').CookiePopupsCollectorResult} collectorResult - Array of processed cookie popups.
 * @param {import('./types').AutoConsentCMPRule[]} existingRules - Array of existing rules.
 * @returns {import('./types').AutoConsentCMPRule[]} Array of matching existing rules.
 */
function findMatchingExistingRules(url, collectorResult, existingRules) {
    return existingRules.filter(rule => {
        if (rule.runContext && rule.runContext.urlPattern) {
            try {
                const pattern = new RegExp(rule.runContext.urlPattern);
                // rule is a match iff:
                // urlPattern matches the crawled site
                return pattern.test(url) ||
                    // OR vendorUrl matches the crawled site (this is more like a heuristic as vendorUrl is not used by Autoconsent)
                    rule.vendorUrl === url ||
                    // OR the rule matched a frame
                    (rule.runContext?.frame && collectorResult.scrapedFrames.some(frame => pattern.test(frame.origin)));
            } catch {
                // Invalid regex, skip
                return false;
            }
        }
        return false;
    });
}

/**
 * Determine if a site should be processed for cookie popup rules based on existing CMP detection.
 * @param {import('./types').AutoconsentResult[]} cmps - The detected CMPs.
 * @returns {boolean} True if the site should be processed (no known CMPs found).
 */
function hasKnownCmp(cmps) {
    return (
        Array.isArray(cmps) &&
        cmps.length > 0 &&
        cmps.some(cmp => cmp &&
            cmp.name &&
            cmp.name.trim() !== '' &&
            // TODO: re-enable this once Autoconsent is more reliable in crawls
            // cmp.succeeded &&
            // we always verify existing autogenerated rules, and override them unless the selector is exactly the same.
            !cmp.name.trim().startsWith('auto_'))
    );
}

/**
 * Read all existing rules from the rules directory. Note that this will ALSO read rules that were generated by this script for other regions.
 * @param {string} rulesDir
 * @returns {Promise<import('./types').AutoConsentCMPRule[]>}
 */
async function readExistingRules(rulesDir) {
    const files = await fs.promises.readdir(rulesDir);
    /** @type {import('./types').AutoConsentCMPRule[]} */
    const result = [];
    await Promise.all(files.map(async file => {
        try {
            const filePath = path.join(rulesDir, file);
            const content = await fs.promises.readFile(filePath, 'utf8');
            const rule = JSON.parse(content);
            result.push(rule);
        } catch (err) {
            console.warn(`Failed to parse rule file ${file}:`, err);
        }
    }));
    return result;
}

/**
 * @param {{
 *  rule: import('./types').AutoConsentCMPRule,
 *  url: string,
 *  rulesDir: string,
 *  testDir: string,
 *  autoconsentDir: string,
 *  region: string,
 * }} params
 * @returns {Promise<import('./types').AutoconsentManifestFileData>}
 */
async function writeRuleFiles({rule, url, rulesDir, testDir, autoconsentDir, region}) {
    const ruleFilePath = path.join(rulesDir, `${rule.name}.json`);
    const relativeRuleFilePath = path.relative(autoconsentDir, ruleFilePath);
    await fs.promises.writeFile(ruleFilePath, JSON.stringify(rule, null, 4));
    const testFilePath = path.join(testDir, `${rule.name}.spec.ts`);
    const relativeTestFilePath = path.relative(autoconsentDir, testFilePath);
    await fs.promises.writeFile(testFilePath, generateTestFile(rule.name, [url], [region]));
    return {
        ruleName: rule.name,
        rulePath: relativeRuleFilePath,
        testPath: relativeTestFilePath,
    };
}

/**
 * Process cookie popups for a single site and generate/update rules.
 * @param {import('./types').GlobalParams} globalParams
 * @param {{
 *  finalUrl: string, // URL of the site
 *  collectorResult: import('./types').CookiePopupsCollectorResult,
 *  existingRules: import('./types').AutoConsentCMPRule[], // existing Autoconsent rules
 * }} params
 * @returns {Promise<{
 * newRuleFiles: import('./types').AutoconsentManifestFileData[],
 * updatedRuleFiles: import('./types').AutoconsentManifestFileData[],
 * keptCount: number,
 * reviewNotes: import('./types').ReviewNote[],
 * updatedExistingRules: import('./types').AutoConsentCMPRule[],
 * }>}
 */
async function processCookiePopupsForSite(globalParams, {finalUrl, collectorResult, existingRules}) {
    const { rulesDir, testDir, autoconsentDir, region } = globalParams;

    /** @type {import('./types').AutoconsentManifestFileData[]} */
    const newRuleFiles = [];
    /** @type {import('./types').AutoconsentManifestFileData[]} */
    const updatedRuleFiles = [];

    const updatedExistingRules = structuredClone(existingRules);

    const llmConfirmedPopups = collectorResult.scrapedFrames.flatMap(frame => frame.potentialPopups).filter(popup => popup.llmMatch);

    // shortcut if no popups with llmMatch
    if (llmConfirmedPopups.length === 0) {
        return { newRuleFiles, updatedRuleFiles, keptCount: 0, reviewNotes: [], updatedExistingRules };
    }

    const matchingRules = findMatchingExistingRules(finalUrl, collectorResult, existingRules);
    console.log(`Detected ${llmConfirmedPopups.length} unhandled cookie popup(s) on ${finalUrl} (matched ${matchingRules.length} existing rules)`);
    const { newRules, rulesToOverride, reviewNotes, keptCount } = generateRulesForSite(region, finalUrl, collectorResult, matchingRules);

    updatedExistingRules.push(...newRules);
    rulesToOverride.forEach(rule => {
        const index = updatedExistingRules.findIndex(r => r.name === rule.name);
        if (index !== -1) {
            updatedExistingRules[index] = rule;
        }
    });

    // Log review notes
    reviewNotes.forEach(note => {
        console.log(`${finalUrl}: ${note.note} ${JSON.stringify(note)}`);
    });

    await Promise.all(rulesToOverride.map(async rule => {
        console.log(`${finalUrl}: overriding rule ${rule.name}`);
        updatedRuleFiles.push(await writeRuleFiles({
            rule,
            url: finalUrl,
            rulesDir,
            testDir,
            autoconsentDir,
            region,
        }));
    }));

    await Promise.all(newRules.map(async ruleToWrite => {
        console.log(`${finalUrl}: new rule ${ruleToWrite.name}`);
        newRuleFiles.push(await writeRuleFiles({
            rule: ruleToWrite,
            url: finalUrl,
            rulesDir,
            testDir,
            autoconsentDir,
            region,
        }));
    }));

    return {
        newRuleFiles,
        updatedRuleFiles,
        keptCount,
        reviewNotes,
        updatedExistingRules,
    };
}

/**
 * Process all crawl data files in the crawl directory.
 * @param {import('./types').GlobalParams} globalParams
 * @param {import('./types').AutoConsentCMPRule[]} existingRules
 * @returns {Promise<void>}
 */
async function processFiles(globalParams, existingRules) {
    const { crawlDir, region, autoconsentManifestFile } = globalParams;
    let totalFiles = 0;
    let totalUnhandled = 0;
    let totalSitesWithNewRules = 0;
    let totalSitesWithPopups = 0;
    let totalSitesWithKnownCmps = 0;
    let totalRules = 0;
    let totalKeptRules = 0;
    let totalOverriddenRules = 0;
    let totalSitesWithKeptRules = 0;
    let totalSitesWithOverriddenRules = 0;

    let existingRulesAfter = structuredClone(existingRules);

    /** @type {Map<string, import('./types').AutoconsentSiteManifest>} */
    const autoconsentManifest = new Map();

    let dir;
    try {
        dir = await fs.promises.opendir(crawlDir);
    } catch (err) {
        console.error('Error reading directory:', err.message);
        return;
    }

    for await (const dirent of dir) {
        if (!dirent.isFile() || path.extname(dirent.name).toLowerCase() !== '.json') {
            continue;
        }
        totalFiles++;
        const fileName = dirent.name;
        const filePath = path.join(crawlDir, fileName);
        const fileContent = await fs.promises.readFile(filePath, 'utf8');
        /** @type {import('./types').CrawlData} */
        let jsonData;
        try {
            jsonData = JSON.parse(fileContent);
            if (!jsonData || !jsonData.data) {
                console.warn(`Skipping ${fileName}: no data field`);
                continue;
            }
        } catch (err) {
            console.error(`Error processing file ${fileName}:`, err.message);
            continue;
        }

        /** @type {import('./types').CookiePopupsCollectorResult} */
        const collectorResult = jsonData.data.cookiepopups;
        if (!collectorResult) {
            console.warn(`Skipping ${fileName}: no cookiepopups data`);
            continue;
        }

        if (collectorResult.scrapedFrames.length === 0) {
            console.warn(`Skipping ${fileName}: no scraped frames data`);
            continue;
        }

        totalSitesWithPopups++;

        if (hasKnownCmp(collectorResult.cmps)) {
            totalSitesWithKnownCmps++;
        } else {
            const llmConfirmedPopups = collectorResult.scrapedFrames.flatMap(frame => frame.potentialPopups).filter(popup => popup.llmMatch);
            /** @type {import('./types').AutoconsentManifestFileData[]} */
            let newRuleFiles = [];
            /** @type {import('./types').AutoconsentManifestFileData[]} */
            let updatedRuleFiles = [];
            let keptCount = 0;
            /** @type {import('./types').ReviewNote[]} */
            let reviewNotes = [];

            if (llmConfirmedPopups.length > 0) {
                totalUnhandled++;
                const result = await processCookiePopupsForSite(globalParams, {
                    finalUrl: jsonData.finalUrl,
                    collectorResult,
                    existingRules: existingRulesAfter,
                });
                ({ newRuleFiles, updatedRuleFiles, keptCount, reviewNotes, updatedExistingRules: existingRulesAfter } = result);
            }

            if (newRuleFiles.length > 0 || updatedRuleFiles.length > 0 || reviewNotes.length > 0) {
                autoconsentManifest.set(fileName, {
                    siteUrl: jsonData.finalUrl,
                    newlyCreatedRules: newRuleFiles,
                    updatedRules: updatedRuleFiles,
                    reviewNotes
                });
            }

            if (newRuleFiles.length > 0 || keptCount > 0 || updatedRuleFiles.length > 0) {
                if (newRuleFiles.length > 0) {
                    totalRules += newRuleFiles.length;
                    totalSitesWithNewRules++;
                }
                if (keptCount > 0) {
                    totalKeptRules += keptCount;
                    totalSitesWithKeptRules++;
                }
                if (updatedRuleFiles.length > 0) {
                    totalOverriddenRules += updatedRuleFiles.length;
                    totalSitesWithOverriddenRules++;
                }
            }
        }
    }

    await fs.promises.writeFile(autoconsentManifestFile, JSON.stringify(Object.fromEntries(autoconsentManifest), null, 4));

    console.log(`Summary for ${region}:`);
    console.log(`Total crawled sites: ${totalFiles}`);
    console.log(`Sites with popup-like elements: ${totalSitesWithPopups}`);
    console.log(`Sites with detected cookie popups: ${totalUnhandled + totalSitesWithKnownCmps}`);
    console.log(`  handled by Autoconsent: ${totalSitesWithKnownCmps}`);
    console.log(`  not handled by Autoconsent: ${totalUnhandled}`);
    console.log(`Generated ${totalRules} new rules for ${totalSitesWithNewRules} sites`);
    console.log(`Kept ${totalKeptRules} rules for ${totalSitesWithKeptRules} sites`);
    console.log(`Updated ${totalOverriddenRules} rules for ${totalSitesWithOverriddenRules} sites`);
    console.log(`Actions manifest for ${autoconsentManifest.size} sites saved in ${autoconsentManifestFile}`);
}

async function main() {
    const program = new Command();
    program
        .description(`Generate autoconsent rules from a crawl directory
    Example:
        node post-processing/generate-autoconsent-rules/main.js --crawl-dir /mnt/efs/shared/crawler-data/2025-05-12/GB/3p-crawl/ --region GB --autoconsent-dir ../autoconsent
    `)
        .option('--crawl-dir <path>', 'Crawl directory')
        .option('--region <region>', 'Crawl region code')
        .option('--autoconsent-dir <path>', 'Autoconsent directory')
        .parse(process.argv);

    const options = program.opts();
    const crawlDir = options.crawlDir;
    const region = options.region;
    const autoconsentDir = options.autoconsentDir;

    if (!crawlDir || !region || !autoconsentDir) {
        program.outputHelp();
        process.exit(1);
    }

    // check that directories exist
    if (!fs.existsSync(autoconsentDir) || !fs.existsSync(crawlDir)) {
        console.error('Autoconsent directory or crawl directory not found:', autoconsentDir, crawlDir);
        process.exit(1);
    }

    const rulesDir = path.join(autoconsentDir, 'rules', 'generated');
    const testDir = path.join(autoconsentDir, 'tests', 'generated');
    const autoconsentManifestFile = path.join(crawlDir, '..', 'autoconsent-manifest.json');

    if (!fs.existsSync(testDir)) {
        await fs.promises.mkdir(testDir, { recursive: true });
    }
    if (!fs.existsSync(rulesDir)) {
        await fs.promises.mkdir(rulesDir, { recursive: true });
    }

    const existingRules = await readExistingRules(rulesDir);
    console.log(`Found ${existingRules.length} existing generated rules`);

    /** @type {import('./types').GlobalParams} */
    const globalParams = {
        crawlDir,
        rulesDir,
        testDir,
        autoconsentDir,
        region,
        autoconsentManifestFile,
    };

    await processFiles(globalParams, existingRules);
}

main();
